/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package uk.gov.di.ipv.cri.kbv.acceptancetest.api;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWEObject;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.RSAEncrypter;
import com.nimbusds.jose.jwk.ECKey;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jwt.EncryptedJWT;
import com.nimbusds.jwt.JWT;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;
import com.nimbusds.oauth2.sdk.AuthorizationRequest;
import com.nimbusds.oauth2.sdk.ResponseType;
import com.nimbusds.oauth2.sdk.Scope;
import com.nimbusds.oauth2.sdk.id.ClientID;
import com.nimbusds.oauth2.sdk.id.State;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.text.ParseException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Base64;
import java.util.Date;
import java.util.Map;
import java.util.UUID;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.blankString;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.not;

@Tag("integration")
class APIIntegrationTest {

    public static final String URN_UUID = "urn:uuid:";
    public static final String SHARED_CLAIMS = "shared_claims";

    @Test
    @DisplayName("should get a session id")
    void shouldGetSessionId()
            throws JOSEException, ParseException, IOException, InterruptedException {
        State state = new State();
        JWT encryptedJWT = createAuthorizationJAR(state);
        Map<String, String> map =
                Map.of(
                        "request",
                        encryptedJWT.getParsedString(),
                        "client_id",
                        TestConfig.CLIENT_ID);

        HttpClient client = HttpClient.newHttpClient();
        ObjectMapper objectMapper = new ObjectMapper();
        HttpRequest request =
                HttpRequest.newBuilder()
                        .uri(URI.create(TestConfig.PRIVATE_API_BASE_URL + "/session"))
                        .POST(
                                HttpRequest.BodyPublishers.ofString(
                                        objectMapper.writeValueAsString(map)))
                        .build();
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        String body = response.body();
        Map<String, String> sessionResponse =
                objectMapper.readValue(body, new TypeReference<>() {});

        assertThat(response.statusCode(), equalTo(201));
        assertThat(sessionResponse.get("session_id"), not(blankString()));
        assertThat(sessionResponse.get("state"), equalTo(state.getValue()));
        assertThat(sessionResponse.get("redirect_uri"), equalTo("http://localhost:8085/callback"));
    }

    private JWT createAuthorizationJAR(State state) throws JOSEException, ParseException {
        Instant now = Instant.now();
        ClientID clientID = new ClientID(TestConfig.CLIENT_ID);
        JWSAlgorithm signingAlgorithm = JWSAlgorithm.parse("ES256");
        JWTSigner jwtSigner = new JWTSigner(getEcPrivateKey());
        JWSHeader header =
                new JWSHeader.Builder(signingAlgorithm).keyID(jwtSigner.getKeyId()).build();

        JWTClaimsSet authClaimsSet =
                new AuthorizationRequest.Builder(ResponseType.CODE, clientID)
                        .redirectionURI(TestConfig.REDIRECT_URL)
                        .scope(new Scope("openid"))
                        .state(state)
                        .build()
                        .toJWTClaimsSet();

        JWTClaimsSet.Builder claimsSetBuilder =
                new JWTClaimsSet.Builder(authClaimsSet)
                        .audience(TestConfig.AUDIENCE)
                        .issuer(TestConfig.ISSUER)
                        .issueTime(Date.from(now))
                        .expirationTime(Date.from(now.plus(2, ChronoUnit.MINUTES)))
                        .notBeforeTime(Date.from(now))
                        .subject(URN_UUID + UUID.randomUUID())
                        .claim(SHARED_CLAIMS, Map.of());

        SignedJWT signedJWT = new SignedJWT(header, claimsSetBuilder.build());
        jwtSigner.signJWT(signedJWT);

        return encryptJWT(signedJWT);
    }

    private EncryptedJWT encryptJWT(SignedJWT signedJWT) {
        try {
            JWEObject jweObject =
                    new JWEObject(
                            new JWEHeader.Builder(
                                            JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A256GCM)
                                    .contentType("JWT")
                                    .build(),
                            new Payload(signedJWT));
            jweObject.encrypt(new RSAEncrypter(getEncryptionPublicKey()));

            return EncryptedJWT.parse(jweObject.serialize());
        } catch (JOSEException | java.text.ParseException e) {
            throw new RuntimeException("JWT encryption failed", e);
        }
    }

    private RSAKey getEncryptionPublicKey() throws java.text.ParseException {
        return RSAKey.parse(
                new String(
                        Base64.getDecoder().decode(TestConfig.ENCRYPTION_PUBLIC_KEY_JWK_BASE64)));
    }

    private ECKey getEcPrivateKey() throws ParseException {
        return ECKey.parse(
                new String(Base64.getDecoder().decode(TestConfig.SIGNING_PRIVATE_KEY_JWK_BASE64)));
    }
}
